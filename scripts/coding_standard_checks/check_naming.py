# No Bugs in Production (NBP) Library
# https://github.com/aenachescu/nbplib
#
# Licensed under the MIT License <http://opensource.org/licenses/MIT>.
# SPDX-License-Identifier: MIT
# Copyright (c) 2019-2020 Alin Enachescu <https://github.com/aenachescu>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import os
import re
from enum import Enum

import clang.cindex
from inflection import *

supportedExtensions = [ ".h", ".c", ".cpp" ]

enumFieldValuesPrefix = []

autoGeneratedFunctionPrefix = [
    "nbp_test_setup_"
]

fieldValueExceptions = [
    "nbp_error_code_e"
]

scriptPath = os.path.dirname(os.path.realpath(__file__))
rootPath = os.path.abspath(os.path.join(scriptPath, '../../'))

class TypedefType(Enum):
    UNKNOWN         = 0
    POINTER_TO_FUNC = 1
    STRUCT          = 2
    ENUM            = 3

def is_test_file(filePath):
    rootPathNoSep = os.path.join(rootPath, '')
    filePathRelative = filePath[len(rootPathNoSep):]

    if filePathRelative.startswith("test/"):
        return True

    return False

def get_number_of_children(node):
    return sum(1 for c in node.get_children())

def get_last_child(node):
    child = None
    for child in node.get_children():
        continue

    return child

def get_number_of_tokens(node):
    return sum(1 for t in node.get_tokens())

def is_valid_enum_field_value_prefix(prefix):
    for p, e in enumFieldValuesPrefix:
        if p == prefix:
            return False, e
    return True, None

def is_valid_field_value(value):
    if len(value) != 10:
        return False

    if not value.startswith("0x"):
        return False

    for i in range(2, len(value)):
        if ((value[i] < '0' or value[i] > '9') and
            (value[i] < 'A' or value[i] > 'F')):
            return False

    return True

def get_header_guard_name(log, filePath):
    rootPathNoSep = os.path.join(rootPath, '')
    filePathRelative = filePath[len(rootPathNoSep):]
    filePathComponents = filePathRelative.split(os.path.sep)
    headerGuard = ""

    if len(filePathComponents) == 0:
        log.error("Invalid relative path: [%s]", filePathRelative)
        return False, ""

    if filePathComponents[0] == "single_header":
        headerGuard = "_H_NBP_NBP"
    elif filePathComponents[0] == "include":
        headerGuard = "_H_NBP_"
        for i in range(1, len(filePathComponents) - 1):
            headerGuard += filePathComponents[i].upper() + "_"
        headerGuard += os.path.splitext(filePathComponents[-1])[0].upper()
    elif filePathComponents[0] == "test":
        headerGuard = "_H_NBP_TEST_"
        for i in range(1, len(filePathComponents) - 1):
            headerGuard += filePathComponents[i].upper() + "_"
        headerGuard += os.path.splitext(filePathComponents[-1])[0].upper()
    else:
        log.error("Unsupported path: [%s]", filePathRelative)
        return False, ""

    return True, headerGuard

def is_auto_generated_function(name):
    for p in autoGeneratedFunctionPrefix:
        if name.startswith(p):
            return True

    return False

def underscore_name(name, upperName=False):
    res = underscore(name)
    if upperName:
        res = res.upper()

    res = re.sub("_+", "_", res)

    if len(res) > 0 and res[0] == '_':
        res = res[1:]

    if len(res) > 0 and res[-1] == '_':
        res = res[:-1]

    return res

def camelize_name(name, upperCaseFirstLetter=True):
    res = re.sub("_+", "_", name)

    if len(res) > 0 and res[0] == '_':
        res = res[1:]

    if len(res) > 0 and res[-1] == '_':
        res = res[:-1]

    res = camelize(underscore(res), upperCaseFirstLetter)

    res = re.sub("_+", "", res)

    return res

def check_unnamed_struct(log, node, parentStructName, filePath):
    status = True

    for field in node.get_children():
        if field.kind == clang.cindex.CursorKind.STRUCT_DECL:
            if field.spelling != "":
                log.error(
                    "Found struct declaration inside another struct. "
                    "Current struct name = [%s]. Parent struct name = [%s]."
                    " File = [%s]. Line = [%d]",
                    field.spelling,
                    parentStructName,
                    filePath,
                    field.location.line
                )
                status = False
                continue

            if not check_unnamed_struct(log, field, parentStructName, filePath):
                status = False
                continue

            continue

        if field.kind != clang.cindex.CursorKind.FIELD_DECL:
            log.error(
                "Unexpected field kind [%s]. File = [%s]. Line = %d",
                field.spelling,
                filePath,
                field.location.line
            )
            status = False
            continue

        expectedFieldName = camelize_name(field.spelling, False)

        if field.spelling != expectedFieldName:
            log.error(
                "Invalid field name. Expected = [%s]. Actual = [%s]. "
                "Struct = %s. File = [%s]. Line = %d",
                expectedFieldName,
                field.spelling,
                parentStructName,
                filePath,
                field.location.line
            )
            status = False
            continue

        log.info(
            "Valid field name [%s]. Struct = %s. File = [%s]. Line = %d",
            field.spelling,
            parentStructName,
            filePath,
            field.location.line
        )

    return status

def check_structs(log, root, filePath):
    log.info("Checking structures... [%s]", filePath)

    foundStructs = []
    status = True

    for child in root.get_children():
        if child.kind != clang.cindex.CursorKind.STRUCT_DECL:
            continue

        if child.location.file.name != filePath:
            continue

        # ignore 'struct nbp_test_t;'
        if get_number_of_children(child) == 0:
            continue

        structName = child.spelling
        expectedTypedefLine = 0
        fieldsStatus = True

        if not structName.startswith("nbp_"):
            log.error(
                "Invalid struct name. The struct name should start with nbp_. "
                "Actual name = [%s]. File = [%s]. Line = %d",
                structName,
                filePath,
                child.location.line
            )
            status = False
            continue

        if not structName.endswith("_t"):
            log.error(
                "Invalid struct name. The struct name should end with _t. "
                "Actual name = [%s]. File = [%s]. Line = %d",
                structName,
                filePath,
                child.location.line
            )
            status = False
            continue

        expectedStructName = underscore_name(structName)

        if expectedStructName != structName:
            log.error(
                "Invalid struct name. Expected = [%s]. Actual = [%s]. "
                "File = [%s]. Line = %d",
                expectedStructName,
                structName,
                filePath,
                child.location.line
            )
            status = False
            continue

        log.info(
            "Found valid struct %s. File = [%s]. Line = %d",
            structName,
            filePath,
            child.location.line
        )

        # check field name
        for field in child.get_children():
            if field.kind == clang.cindex.CursorKind.STRUCT_DECL:
                if field.spelling != "":
                    log.error(
                        "Found struct declaration inside another struct. "
                        "Current struct name = [%s]. Parent struct name = [%s]."
                        " File = [%s]. Line = [%d]",
                        field.spelling,
                        structName,
                        filePath,
                        field.location.line
                    )
                    fieldsStatus = False
                    continue

                if not check_unnamed_struct(log, field, structName, filePath):
                    fieldsStatus = False
                    continue

                continue

            if field.kind != clang.cindex.CursorKind.FIELD_DECL:
                log.error(
                    "Unexpected field kind [%s]. File = [%s]. Line = %d",
                    field.spelling,
                    filePath,
                    field.location.line
                )
                fieldsStatus = False
                continue

            expectedTypedefLine = field.location.line + 2
            expectedFieldName = camelize_name(field.spelling, False)

            if field.spelling != expectedFieldName:
                log.error(
                    "Invalid field name. Expected = [%s]. Actual = [%s]. "
                    "Struct = %s. File = [%s]. Line = %d",
                    expectedFieldName,
                    field.spelling,
                    structName,
                    filePath,
                    field.location.line
                )
                fieldsStatus = False
                continue

            log.info(
                "Valid field name [%s]. Struct = %s. File = [%s]. Line = %d",
                field.spelling,
                structName,
                filePath,
                field.location.line
            )

        if not fieldsStatus:
            status = False

        foundStructs.append(tuple((structName, expectedTypedefLine)))

    if status:
        log.info("Structure names are ok: %s", filePath)

    return status, foundStructs

def check_global_variables(log, root, filePath):
    log.info("Checking global variables... [%s]", filePath)

    status = True
    varNamePrefix = "gInternalNbp"

    if is_test_file(filePath):
        varNamePrefix = "g"

    for child in root.get_children():
        if child.kind != clang.cindex.CursorKind.VAR_DECL:
            continue

        if child.location.file.name != filePath:
            continue

        if not child.spelling.startswith(varNamePrefix):
            log.error(
                "Invalid global variable name. The name should start with %s. "
                "Name = [%s]. File = [%s]. Line = %d",
                varNamePrefix,
                child.spelling,
                filePath,
                child.location.line
            )
            status = False
            continue

        varNameNoPrefix = child.spelling[len(varNamePrefix):]
        expectedVarName = camelize_name(varNameNoPrefix)

        if expectedVarName != varNameNoPrefix:
            log.error(
                "Invalid global variable name. Expected = [%s%s]. "
                "Actual = [%s]. File = [%s]. Line = %d",
                varNamePrefix,
                expectedVarName,
                child.spelling,
                filePath,
                child.location.line
            )
            status = False
            continue

        log.info(
            "Valid global variable name [%s]. File = [%s]. Line = %d",
            child.spelling,
            filePath,
            child.location.line
        )

    if status:
        log.info("Global variable names are ok: %s", filePath)

    return status

def check_enum_fields(log, enum, filePath, prefix, enumName):
    status = True
    enumFieldValuePrefix = ""
    expectedTypedefLine = 0

    for field in enum.get_children():
        if field.kind != clang.cindex.CursorKind.ENUM_CONSTANT_DECL:
            log.error(
                "Unexpected enum field kind [%s]. Enum = %s. File = %s. "
                "Line = %d",
                field.kind,
                enumName,
                filePath,
                field.location.line
            )
            status = False
            continue

        fieldName = field.spelling
        expectedTypedefLine = field.location.line + 2

        if not fieldName.startswith(prefix):
            log.error(
                "Invalid enum field name. The name should start with %s. "
                "Actual name = [%s]. Enum name = %s. File = [%s]. Line = %d",
                prefix,
                fieldName,
                enumName,
                filePath,
                field.location.line
            )
            status = False
            continue

        expectedFieldName = underscore_name(fieldName)

        if expectedFieldName != fieldName:
            log.error(
                "Invalid enum field name. Expected = [%s]. Actual = [%s]. "
                "Enum name = %s. File = [%s]. Line = %d",
                expectedFieldName,
                fieldName,
                enumName,
                filePath,
                field.location.line
            )
            status = False
            continue

        log.info(
            "Valid enum field name [%s]. Enum name = %s. File = [%s]. "
            "Line = %d",
            fieldName,
            enumName,
            filePath,
            field.location.line
        )

        if enumName in fieldValueExceptions:
            continue

        if get_number_of_children(field) != 1:
            log.error(
                "Enum field has no value. Field = %s. Enum = %s. File = [%s]. "
                "Line = %d",
                fieldName,
                enumName,
                filePath,
                field.location.line
            )
            status = False
            continue

        fieldValue = next(field.get_children())

        if fieldValue.kind != clang.cindex.CursorKind.INTEGER_LITERAL:
            log.error(
                "Unexpected enum field value kind [%s]. Field = %s. Enum = %s."
                " File = [%s]. Line = %d",
                fieldValue.kind,
                fieldName,
                enumName,
                filePath,
                fieldValue.location.line
            )
            status = False
            continue

        if get_number_of_tokens(fieldValue) != 1:
            log.error(
                "Unexpected number of tokens. Field = %s. Enum = %s. "
                "File = [%s]. Line = %d",
                fieldName,
                enumName,
                filePath,
                fieldName.location.line
            )
            status = False
            continue

        fieldValueToken = next(fieldValue.get_tokens())

        if fieldValueToken.kind != clang.cindex.TokenKind.LITERAL:
            log.error(
                "Unexpected enum field value token kind [%s]. Field = %s. "
                "Enum = %s. File = [%s]. Line = %d",
                fieldValueToken.kind,
                fieldName,
                enumName,
                filePath,
                fieldValue.location.line
            )
            status = False
            continue

        fieldValueStr = fieldValueToken.spelling

        if not is_valid_field_value(fieldValueStr):
            log.error(
                "Field value is not hex [%s]. Field = %s. Enum = %s. "
                "File = [%s]. Line = %d",
                fieldValueStr,
                fieldName,
                enumName,
                filePath,
                fieldValue.location.line
            )
            status = False
            continue

        if enumFieldValuePrefix == "":
            enumFieldValuePrefix = fieldValueStr[2:4]

            isValidPrefix, usedBy = is_valid_enum_field_value_prefix(
                enumFieldValuePrefix
            )
            if not isValidPrefix:
                log.error(
                    "Enum field value prefix already used. Prefix = %s. "
                    "Used by = %s. Enum = %s. File = [%s]. Line = %d",
                    enumFieldValuePrefix,
                    usedBy,
                    enumName,
                    filePath,
                    fieldValue.location.line
                )
                status = False
                break

            enumFieldValuesPrefix.append(
                tuple((enumFieldValuePrefix, enumName))
            )

        fieldValuePrefix = fieldValueStr[2:4]

        if fieldValuePrefix == "00":
            log.error(
                "Field value has no prefix. Field = %s. Enum = %s. File = [%s]."
                " Line = %d",
                fieldName,
                enumName,
                filePath,
                fieldValue.location.line
            )
            status = False
            continue

        if fieldValuePrefix != enumFieldValuePrefix:
            log.error(
                "Unexpected enum field value prefix. Expected = %s. "
                "Actual = %s. Field = %s. Enum = %s. File = [%s]. Line = %d",
                enumFieldValuePrefix,
                fieldValuePrefix,
                fieldName,
                enumName,
                filePath,
                fieldValue.location.line
            )

        log.info(
            "Valid enum field value [%s]. Field = %s. Enum = %s. File = [%s]. "
            "Line = %d",
            fieldValueStr,
            fieldName,
            enumName,
            filePath,
            fieldValue.location.line
        )

    return status, expectedTypedefLine

def check_enums(log, root, filePath):
    log.info("Checking enums... [%s]", filePath)

    status = True
    foundEnums = []

    for enum in root.get_children():
        if enum.kind != clang.cindex.CursorKind.ENUM_DECL:
            continue

        if enum.location.file.name != filePath:
            continue

        enumName = enum.spelling

        if not enumName.startswith("nbp_"):
            log.error(
                "Invalid enum name. The name should start with nbp_. "
                "Actual name = [%s]. File = [%s]. Line = %d",
                enumName,
                filePath,
                enum.location.line
            )
            status = False
            continue

        if not enumName.endswith("_e"):
            log.error(
                "Invalid enum name. The name should end with _t. "
                "Actual name = [%s]. File = [%s]. Line = %d",
                enumName,
                filePath,
                enum.location.line
            )
            status = False
            continue

        expectedEnumName = underscore_name(enumName)

        if expectedEnumName != enumName:
            log.error(
                "Invalid enum name. Expected = [%s]. Actual = [%s]. "
                "File = [%s]. Line = %d",
                expectedEnumName,
                enumName,
                filePath,
                enum.location.line
            )
            status = False
            continue

        log.info(
            "Found valid enum %s. File = [%s]. Line = %d",
            enumName,
            filePath,
            enum.location.line
        )

        prefix = ""
        enumNameWords = enumName.split("_")

        for i in range(1, len(enumNameWords) - 1):
            prefix += enumNameWords[i][0]

        enumFieldsStatus, expectedTypedefLine = check_enum_fields(
            log,
            enum,
            filePath,
            prefix,
            enumName
        )
        if not enumFieldsStatus:
            status = False
            continue

        foundEnums.append(tuple((enumName, expectedTypedefLine)))

    if status:
        log.info("Enum names are ok: %s", filePath)

    return status, foundEnums

def get_typedef_type(log, filePath, typedef):
    numberOfChildren = get_number_of_children(typedef)

    if numberOfChildren == 0:
        if not "(" in typedef.underlying_typedef_type.spelling:
            log.error(
                "Unsupported typedef. Underlying type = [%s]. Type = [%s]. "
                "File = [%s]. Line = %d",
                typedef.type.spelling,
                typedef.underlying_typedef_type.spelling,
                filePath,
                typedef.location.line
            )
            return TypedefType.UNKNOWN, []
        return TypedefType.POINTER_TO_FUNC, [ typedef.type.spelling ]

    if numberOfChildren == 1:
        child = next(typedef.get_children())
        if child.kind == clang.cindex.CursorKind.TYPE_REF:
            if child.spelling.startswith("struct "):
                details = [ child.spelling, typedef.type.spelling ]
                return TypedefType.STRUCT, details
            if child.spelling.startswith("enum "):
                details = [ child.spelling, typedef.type.spelling ]
                return TypedefType.ENUM, details

            log.error(
                "Unknown type ref [%s]. File = [%s]. Line = %d",
                child.spelling,
                filePath,
                child.location.line
            )
            return TypedefType.UNKNOWN, []

    for param in typedef.get_children():
        if param.kind != clang.cindex.CursorKind.PARM_DECL:
            log.error(
                "Unexpected typedef param kind [%s]. Typedef = %s. "
                "File = [%s]. Line = %d",
                param.kind,
                typedef.spelling,
                filePath,
                typedef.location.line
            )
            return TypedefType.UNKNOWN, []

    return TypedefType.POINTER_TO_FUNC, [ typedef.spelling ]

def check_typedef_enum(log, filePath, line, name):
    if not name.startswith("nbp_"):
        log.error(
            "Invalid typedef enum name. The name should start with nbp_. "
            "Name = [%s]. File = [%s]. Line = %d",
            name,
            filePath,
            line
        )
        return False

    if not name.endswith("_e"):
        log.error(
            "Invalid typedef enum name. The name should end with _e. "
            "Name = [%s]. File = [%s]. Line = %d",
            name,
            filePath,
            line
        )
        return False

    expectedName = underscore_name(name)

    if expectedName != name:
        log.error(
            "Invalid typedef enum name. Expected = [%s]. Name = [%s]. "
            "File = [%s]. Line = %d",
            expectedName,
            name,
            filePath,
            line
        )
        return False

    log.info(
        "Valid typedef enum name [%s]. File = [%s]. Line = %d",
        name,
        filePath,
        line
    )

    return True

def check_typedef_struct(log, filePath, line, name):
    if not name.startswith("nbp_"):
        log.error(
            "Invalid typedef struct name. The name should start with nbp_. "
            "Name = [%s]. File = [%s]. Line = %d",
            name,
            filePath,
            line
        )
        return False

    if not name.endswith("_t"):
        log.error(
            "Invalid typedef struct name. The name should end with _t. "
            "Name = [%s]. File = [%s]. Line = %d",
            name,
            filePath,
            line
        )
        return False

    expectedName = underscore_name(name)

    if expectedName != name:
        log.error(
            "Invalid typedef struct name. Expected = [%s]. Name = [%s]. "
            "File = [%s]. Line = %d",
            expectedName,
            name,
            filePath,
            line
        )
        return False

    log.info(
        "Valid typedef struct name [%s]. File = [%s]. Line = %d",
        name,
        filePath,
        line
    )

    return True

def check_typedef_pfn(log, filePath, line, name):
    if not name.startswith("nbp_"):
        log.error(
            "Invalid pointer to function name. The name should start with "
            "nbp_. Name = [%s]. File = [%s]. Line = %d",
            name,
            filePath,
            line
        )
        return False

    if not name.endswith("_pfn_t"):
        log.error(
            "Invalid pointer to function name. The name should end with _pfn_t."
            " Name = [%s]. File = [%s]. Line = %d",
            name,
            filePath,
            line
        )
        return False

    expectedName = underscore_name(name)

    if expectedName != name:
        log.error(
            "Invalid pointer to function name. Expected = [%s]. Name = [%s]. "
            "File = [%s]. Line = %d",
            expectedName,
            name,
            filePath,
            line
        )
        return False

    log.info(
        "Valid pointer to function typedef [%s]. File = [%s]. Line = %d",
        name,
        filePath,
        line
    )

    return True

def check_expected_typedef_struct(log, filePath, expectedTypedefStructs,
    actualTypedefStructs):
    status = True

    for structName, expectedLine in expectedTypedefStructs:
        s = [struct for struct in actualTypedefStructs
                if struct[1] == expectedLine]
        if len(s) == 0:
            log.error(
                "Expected [typedef struct %s %s] on line %d. File = [%s]",
                structName,
                structName,
                expectedLine,
                filePath
            )
            status = False
            continue

        if len(s) > 1:
            log.error(
                "Too many typedefs on same line [%d]. File = [%s]",
                expectedLine,
                filePath
            )
            status = False
            continue

        typeName, line, underlying = s[0]

        if structName != typeName or ("struct " + structName) != underlying:
            log.error(
                "Expected [typedef struct %s %s] on line %d. Actual [typedef "
                "%s %s]",
                structName,
                structName,
                expectedLine,
                underlying,
                typeName
            )
            status = False
            continue

        log.info(
            "Found typedef for struct %s. File = [%s]. Line = %d",
            structName,
            filePath,
            line
        )

    return status

def check_expected_typedef_enum(log, filePath, expectedTypedefEnums,
    actualTypedefEnums):
    status = True

    for enumName, expectedLine in expectedTypedefEnums:
        s = [enum for enum in actualTypedefEnums
                if enum[1] == expectedLine]
        if len(s) == 0:
            log.error(
                "Expected [typedef enum %s %s] on line %d. File = [%s]",
                enumName,
                enumName,
                expectedLine,
                filePath
            )
            status = False
            continue

        if len(s) > 1:
            log.error(
                "Too many typedefs on same line [%d]. File = [%s]",
                expectedLine,
                filePath
            )
            status = False
            continue

        typeName, line, underlying = s[0]

        if enumName != typeName or ("enum " + enumName) != underlying:
            log.error(
                "Expected [typedef enum %s %s] on line %d. Actual [typedef "
                "%s %s]",
                enumName,
                enumName,
                expectedLine,
                underlying,
                typeName
            )
            status = False
            continue

        log.info(
            "Found typedef for enum %s. File = [%s]. Line = %d",
            enumName,
            filePath,
            line
        )

    return status

def check_typedefs(log, root, filePath, structs, enums):
    log.info("Checking typedefs... [%s]", filePath)

    status = True

    typedefStructs = []
    typedefEnums   = []

    for typedef in root.get_children():
        if typedef.kind != clang.cindex.CursorKind.TYPEDEF_DECL:
            continue

        if typedef.location.file.name != filePath:
            continue

        typedefType, details = get_typedef_type(log, filePath, typedef)
        if typedefType == TypedefType.UNKNOWN:
            log.error("Typedef type is unknown")
            status = False
            continue

        if typedefType == TypedefType.POINTER_TO_FUNC:
            st = check_typedef_pfn(
                log,
                filePath,
                typedef.location.line,
                details[0]
            )
            if not st:
                status = False
            continue
        elif typedefType == TypedefType.ENUM:
            st = check_typedef_enum(
                log,
                filePath,
                typedef.location.line,
                details[1]
            )
            if not st:
                status = False
                continue

            typedefEnums.append(
                tuple((details[1], typedef.location.line, details[0]))
            )
            continue
        elif typedefType == TypedefType.STRUCT:
            st = check_typedef_struct(
                log,
                filePath,
                typedef.location.line,
                details[1]
            )
            if not st:
                status = False
                continue

            typedefStructs.append(
                tuple((details[1], typedef.location.line, details[0]))
            )
            continue

        log.error("Unknown typedef type")
        status = False
        continue

    st = check_expected_typedef_struct(
        log,
        filePath,
        structs,
        typedefStructs
    )
    if not st:
        status = False

    st = check_expected_typedef_enum(
        log,
        filePath,
        enums,
        typedefEnums
    )
    if not st:
        status = False

    if status:
        log.info("Typedefs are ok: %s", filePath)

    return status

def check_macros(log, root, filePath):
    log.info("Checking macros... [%s]", filePath)

    status = True
    firstMacro = True
    isHeader = False

    if os.path.splitext(filePath)[1] == ".h":
        isHeader = True

    for macro in root.get_children():
        if macro.kind != clang.cindex.CursorKind.MACRO_DEFINITION:
            continue

        if macro.location.file == None:
            continue
        if macro.location.file.name != filePath:
            continue

        if isHeader and firstMacro:
            firstMacro = False

            st, headerGuard = get_header_guard_name(log, filePath)
            if not st:
                status = False
                continue

            if macro.spelling != headerGuard:
                log.error(
                    "Invalid header guard name. Expected = [%s]. Actual = [%s]."
                    " File = [%s]. Line = %d",
                    headerGuard,
                    macro.spelling,
                    filePath,
                    macro.location.line
                )
                status = False
                continue

            log.info(
                "Valid header guard name [%s]. File = [%s]. Line = %d",
                headerGuard,
                filePath,
                macro.location.line
            )
            continue

        if (not is_test_file(filePath) and
            not macro.spelling.startswith("NBP_") and
            not macro.spelling.startswith("INTERNAL_NBP_")):
            log.error(
                "Invalid macro name. The name should start with NBP_ or "
                "INTERNAL_NBP_. Name = [%s]. File = [%s]. Line = %d",
                macro.spelling,
                filePath,
                macro.location.line
            )
            status = False
            continue

        expectedName = underscore_name(macro.spelling, True)

        if macro.spelling != expectedName:
            log.error(
                "Invalid macro name. Expected = [%s]. Actual = [%s]. File = "
                "[%s]. Line = %d",
                expectedName,
                macro.spelling,
                filePath,
                macro.location.line
            )
            status = False
            continue

        log.info(
            "Valid macro name [%s]. File = [%s]. Line = %d",
            macro.spelling,
            filePath,
            macro.location.line
        )

    if status:
        log.info("Macros are ok: %s", filePath)

    return status

def check_function_name(log, filePath, func):
    if func.spelling == "main":
        return True

    if (not is_test_file(filePath) and
        not func.spelling.startswith("nbp_") and
        not func.spelling.startswith("internal_nbp_")):
        log.error(
            "Invalid function name. The name should start with nbp_ or "
            "internal_nbp_. Name = [%s]. File = [%s]. Line = %d",
            func.spelling,
            filePath,
            func.location.line
        )
        return False

    expectedName = underscore_name(func.spelling)

    if func.spelling != expectedName:
        log.error(
            "Invalid function name. Expected = [%s]. Actual = [%s]. "
            "File = [%s]. Line = %d",
            expectedName,
            func.spelling,
            filePath,
            func.location.line
        )
        return False

    log.info(
        "Valid function name [%s]. File = [%s]. Line = %d",
        func.spelling,
        filePath,
        func.location.line
    )

    return True

def check_function_params(log, filePath, func):
    status = True

    paramNamePrefix = ""
    if is_auto_generated_function(func.spelling):
        paramNamePrefix = "nbpParam"

    for param in func.get_children():
        if param.kind != clang.cindex.CursorKind.PARM_DECL:
            continue

        if param.spelling == "":
            log.error(
                "Empty parameter name. Function = [%s]. File = [%s]. Line = %d",
                func.spelling,
                filePath,
                param.location.line
            )
            status = False
            continue

        if not param.spelling.startswith(paramNamePrefix):
            log.error(
                "Invalid parameter name. The name should start with [%s]. "
                "Name = [%s]. Function = [%s]. File = [%s]. Line = %d",
                paramNamePrefix,
                param.spelling,
                func.spelling,
                filePath,
                param.location.line
            )
            status = False
            continue

        paramNameNoPrefix = param.spelling[len(paramNamePrefix):]
        expectedParamName = camelize_name(
            paramNameNoPrefix,
            len(paramNamePrefix) > 0
        )

        if paramNameNoPrefix != expectedParamName:
            log.error(
                "Invalid parameter name. Expected = [%s%s]. Actual = [%s]. "
                "Function = [%s]. File = [%s]. Line = %d",
                paramNamePrefix,
                expectedParamName,
                param.spelling,
                func.spelling,
                filePath,
                param.location.line
            )
            status = False
            continue

        log.info(
            "Valid parameter name. Name = [%s]. Function = [%s]. File = [%s]. "
            "Line = %d",
            param.spelling,
            func.spelling,
            filePath,
            param.location.line
        )

    return status

def check_functions(log, root, filePath):
    log.info("Checking functions... [%s]", filePath)

    status = True

    for func in root.get_children():
        if func.kind != clang.cindex.CursorKind.FUNCTION_DECL:
            continue

        if func.location.file == None:
            continue
        if func.location.file.name != filePath:
            continue

        if not check_function_name(log, filePath, func):
            status = False

        if not check_function_params(log, filePath, func):
            status = False

    if status:
        log.info("Functions are ok: %s", filePath)

    return status

def check_local_variables_impl(log, func, filePath, funcName):
    status = True

    for localVar in func.get_children():
        if localVar.kind != clang.cindex.CursorKind.VAR_DECL:
            continue

        expectedLocalVarName = camelize_name(localVar.spelling, False)

        if localVar.spelling != expectedLocalVarName:
            log.error(
                "Invalid local variable name. Expected = [%s]. Actual = [%s]. "
                "Function = [%s]. File = [%s]. Line = %d",
                expectedLocalVarName,
                localVar.spelling,
                funcName,
                filePath,
                localVar.location.line
            )
            status = False
            continue

        log.info(
            "Valid local variable name [%s]. Function = [%s]. File = [%s]. "
            "Line = %d",
            localVar.spelling,
            funcName,
            filePath,
            localVar.location.line
        )

    for c in func.get_children():
        if not check_local_variables_impl(log, c, filePath, funcName):
            status = False

    return status

def check_local_variables(log, root, filePath):
    log.info("Checking local variables... [%s]", filePath)

    status = True

    for func in root.get_children():
        if func.kind != clang.cindex.CursorKind.FUNCTION_DECL:
            continue

        if func.location.file == None:
            continue
        if func.location.file.name != filePath:
            continue

        if not check_local_variables_impl(log, func, filePath, func.spelling):
            status = False

    if status:
        log.info("Local variables are ok: %s", filePath)

    return status

def check_if_statement_braces(log, node, filePath, funcName):
    children = node.get_children()
    next(children)

    thenBlock = next(children)
    elseBlock = None

    status = True

    if get_number_of_children(node) == 3:
        elseBlock = get_last_child(node)

    while True:
        if thenBlock.kind != clang.cindex.CursorKind.COMPOUND_STMT:
            log.error(
                "Use braces even if the 'if' statement has a single "
                "instruction. Function = [%s]. File = [%s]. Line = %d",
                funcName,
                filePath,
                node.location.line,
            )
            status = False
        else:
            log.info(
                "The 'if' statement has braces. Function = [%s]. File = [%s]. "
                "Line = %d",
                funcName,
                filePath,
                node.location.line
            )

        if not elseBlock:
            break

        if elseBlock.kind == clang.cindex.CursorKind.IF_STMT:
            break

        if elseBlock.kind != clang.cindex.CursorKind.COMPOUND_STMT:
            log.error(
                "Use braces even if the 'else' statement has a single "
                "instruction. Function = [%s]. File = [%s]. Line = %d",
                funcName,
                filePath,
                elseBlock.location.line
            )
            status = False
        else:
            log.info(
                "The 'else' statement has braces. Function = [%s]. "
                "File = [%s]. Line = %d",
                funcName,
                filePath,
                elseBlock.location.line
            )

        break

    return status

def check_while_statement_braces(log, node, filePath, funcName):
    lastChild = get_last_child(node)

    if lastChild.kind == clang.cindex.CursorKind.COMPOUND_STMT:
        log.info(
            "The 'while' statement has braces. Function = [%s]. File = [%s]. "
            "Line = %d",
            funcName,
            filePath,
            node.location.line
        )
        return True

    log.error(
        "Use braces even if the 'while' statement has a single instruction. "
        "Function = [%s]. File = [%s]. Line = %d",
        funcName,
        filePath,
        node.location.line
    )

    return False

def check_do_statement_braces(log, node, filePath, funcName):
    firstChild = next(node.get_children())

    if firstChild.kind == clang.cindex.CursorKind.COMPOUND_STMT:
        log.info(
            "The 'do while' statement has braces. Function = [%s]. "
            "File = [%s]. Line = %d",
            funcName,
            filePath,
            node.location.line
        )
        return True

    log.error(
        "Use braces even if the 'do while' statement has a single instruction. "
        "Function = [%s]. File = [%s]. Line = %d",
        funcName,
        filePath,
        node.location.line
    )

    return False

def check_for_statement_braces(log, node, filePath, funcName):
    lastChild = get_last_child(node)

    if lastChild.kind == clang.cindex.CursorKind.COMPOUND_STMT:
        log.info(
            "The 'for' statement has braces. Function = [%s]. File = [%s]. "
            "Line = %d",
            funcName,
            filePath,
            node.location.line
        )
        return True

    log.error(
        "Use braces even if the 'for' statement has a single instruction. "
        "Function = [%s]. File = [%s]. Line = %d",
        funcName,
        filePath,
        node.location.line
    )

    return False

def check_braces_impl(log, func, filePath, funcName):
    status = True

    for child in func.get_children():
        if child.kind == clang.cindex.CursorKind.IF_STMT:
            check_if_statement_braces(log, child, filePath, funcName)
            continue
        if child.kind == clang.cindex.CursorKind.WHILE_STMT:
            check_while_statement_braces(log, child, filePath, funcName)
            continue
        if child.kind == clang.cindex.CursorKind.DO_STMT:
            check_do_statement_braces(log, child, filePath, funcName)
            continue
        if child.kind == clang.cindex.CursorKind.FOR_STMT:
            check_for_statement_braces(log, child, filePath, funcName)
            continue

    for c in func.get_children():
        if not check_braces_impl(log, c, filePath, funcName):
            status = False

    return status

def check_braces(log, root, filePath):
    log.info("Checking braces... [%s]", filePath)

    status = True

    for func in root.get_children():
        if func.kind != clang.cindex.CursorKind.FUNCTION_DECL:
            continue

        if func.location.file == None:
            continue
        if func.location.file.name != filePath:
            continue

        if not check_braces_impl(log, func, filePath, func.spelling):
            status = False

    if status:
        log.info("Braces are ok: %s", filePath)

    return status

def check_naming(log, filePath):
    log.info("Checking naming... [%s]", filePath)

    hasSupportedExtension = False

    for ext in supportedExtensions:
        if filePath.endswith(ext):
            hasSupportedExtension = True
            break

    if not hasSupportedExtension:
        log.info("Unsupported extension for file [%s]", filePath)
        return True

    status = True

    index = clang.cindex.Index.create()
    translationUnit = index.parse(
        filePath,
        options=clang.cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD
    )

    st, structs = check_structs(log, translationUnit.cursor, filePath)
    if not st:
        status = False

    if not check_global_variables(log, translationUnit.cursor, filePath):
        status = False

    st, enums = check_enums(log, translationUnit.cursor, filePath)
    if not st:
        status = False

    st = check_typedefs(log, translationUnit.cursor, filePath, structs, enums)
    if not st:
        status = False

    if not check_macros(log, translationUnit.cursor, filePath):
        status = False

    if not check_functions(log, translationUnit.cursor, filePath):
        status = False

    if not check_local_variables(log, translationUnit.cursor, filePath):
        status = False

    if not check_braces(log, translationUnit.cursor, filePath):
        status = False

    if status:
        log.info("Naming ok: [%s]", filePath)

    return status
